kernel.c
#include "drivers/vga.h"
#include "drivers/keyboard.h"
#include "fs/fs.h"
#include "shell/shell.h"

void kernel_main(void) {
    vga_init();
    vga_clear();
    
    vga_set_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK);
    vga_puts("Booting MiniOS...\n");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    
    vga_puts("Initializing keyboard... ");
    keyboard_init();
    vga_set_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK);
    vga_puts("[OK]\n");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    
    vga_puts("Initializing filesystem... ");
    fs_init();
    vga_set_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK);
    vga_puts("[OK]\n");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    
    vga_putch('\n');
    
    // Clear screen before starting shell
    vga_clear();
    
    shell_init();
    shell_run();
    
    for(;;) __asm__ volatile("hlt");
}


boot.asm
; ---------------------------------------------------------
; Bootloader untuk TinyOS - Load kernel dan masuk protected mode
; File: boot.asm
; ---------------------------------------------------------

[org 0x7C00]
[bits 16]

KERNEL_OFFSET equ 0x1000        ; Kernel di-load ke sini
KERNEL_SECTORS equ 20           ; Jumlah sector kernel (sesuaikan jika perlu)

start:
    ; Setup segments
    cli
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00
    sti

    ; Print loading message
    mov si, msg_loading
    call print_string

    ; Load kernel dari disk
    call load_kernel

    ; Print entering protected mode message
    mov si, msg_protected
    call print_string

    ; Masuk protected mode
    cli
    lgdt [gdt_descriptor]
    
    mov eax, cr0
    or eax, 0x1
    mov cr0, eax
    
    jmp CODE_SEG:init_pm

; ---------------------------------------------------------
; Load kernel dari disk ke memory
; ---------------------------------------------------------
load_kernel:
    mov ah, 0x02                ; BIOS read sectors
    mov al, KERNEL_SECTORS      ; Jumlah sectors
    mov ch, 0                   ; Cylinder 0
    mov cl, 2                   ; Start dari sector 2 (setelah bootloader)
    mov dh, 0                   ; Head 0
    mov dl, 0x80                ; First hard disk
    mov bx, KERNEL_OFFSET       ; ES:BX = destinasi buffer
    int 0x13
    
    jc disk_error               ; Jump jika error
    ret

disk_error:
    mov si, msg_error
    call print_string
    jmp $

; ---------------------------------------------------------
; Print string (real mode)
; ---------------------------------------------------------
print_string:
    pusha
.loop:
    lodsb
    or al, al
    jz .done
    mov ah, 0x0E
    int 0x10
    jmp .loop
.done:
    popa
    ret

; ---------------------------------------------------------
; Protected Mode
; ---------------------------------------------------------
[bits 32]
init_pm:
    ; Setup segment registers
    mov ax, DATA_SEG
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, 0x9FC00

    ; Jump ke kernel
    call KERNEL_OFFSET

    ; Jika kernel return, hang
    jmp $

; ---------------------------------------------------------
; GDT (Global Descriptor Table)
; ---------------------------------------------------------
[bits 16]
gdt_start:

gdt_null:
    dd 0x0
    dd 0x0

gdt_code:
    dw 0xFFFF       ; Limit (bits 0-15)
    dw 0x0          ; Base (bits 0-15)
    db 0x0          ; Base (bits 16-23)
    db 10011010b    ; Access byte
    db 11001111b    ; Flags + Limit (bits 16-19)
    db 0x0          ; Base (bits 24-31)

gdt_data:
    dw 0xFFFF       ; Limit (bits 0-15)
    dw 0x0          ; Base (bits 0-15)
    db 0x0          ; Base (bits 16-23)
    db 10010010b    ; Access byte
    db 11001111b    ; Flags + Limit (bits 16-19)
    db 0x0          ; Base (bits 24-31)

gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

CODE_SEG equ gdt_code - gdt_start
DATA_SEG equ gdt_data - gdt_start

; ---------------------------------------------------------
; Messages
; ---------------------------------------------------------
msg_loading db "Loading TinyOS kernel...", 13, 10, 0
msg_protected db "Entering protected mode...", 13, 10, 0
msg_error db "Disk read error!", 13, 10, 0

; ---------------------------------------------------------
; Boot signature
; ---------------------------------------------------------
times 510-($-$$) db 0
dw 0xAA55


kernel_entry.asm
; kernel_entry.asm
bits 32
extern kernel_main

section .text.entry
global kernel_entry

kernel_entry:
    ; set up segments and stack (protected mode)
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, 0x9FC00

    ; call C kernel entry
    call kernel_main

.hang:
    cli
    hlt
    jmp .hang


link.ld
OUTPUT_FORMAT("binary")
ENTRY(kernel_entry)

SECTIONS {
    . = 0x1000;

    .text : {
        *(.text.entry)
        *(.text*)
    }

    .rodata : {
        *(.rodata*)
    }

    .data : {
        *(.data*)
    }

    .bss : {
        *(.bss*)
        *(COMMON)
    }
}


makefile
ASM = nasm
CC = gcc
LD = ld
OBJDUMP = objdump

CFLAGS = -m32 -ffreestanding -fno-builtin -fno-pie -nostdlib -nostdinc \
         -Wall -Wextra -O2 -fno-stack-protector \
         -Idrivers -Ifs -Ishell -Ilib

LDFLAGS = -m elf_i386 -T link.ld

DRIVER_SRCS = drivers/vga.c drivers/keyboard.c
FS_SRCS = fs/fs.c
SHELL_SRCS = shell/shell.c
LIB_SRCS = lib/string.c

DRIVER_OBJS = $(DRIVER_SRCS:.c=.o)
FS_OBJS = $(FS_SRCS:.c=.o)
SHELL_OBJS = $(SHELL_SRCS:.c=.o)
LIB_OBJS = $(LIB_SRCS:.c=.o)

OBJS = kernel_entry.o kernel.o $(DRIVER_OBJS) $(FS_OBJS) $(SHELL_OBJS) $(LIB_OBJS)

all: os-image.bin

# Build bootloader (512 bytes)
bootloader.bin: boot.asm
	@echo "[ASM] $<"
	@nasm -f bin $< -o $@
	@truncate -s 512 $@

# kernel entry
kernel_entry.o: kernel_entry.asm
	@echo "[ASM] $<"
	@nasm -f elf32 $< -o $@

# C -> objects
%.o: %.c
	@echo "[CC]  $<"
	@$(CC) $(CFLAGS) -c $< -o $@

# Link kernel (binary)
kernel.bin: $(OBJS) link.ld
	@echo "[LD]  kernel.bin"
	@$(LD) $(LDFLAGS) $(OBJS) -o $@

# final image: bootloader + kernel
os-image.bin: bootloader.bin kernel.bin
	@cat bootloader.bin kernel.bin > $@
	@echo ""
	@echo "====================================="
	@echo "âœ… MiniOS built successfully!"
	@echo "====================================="
	@ls -lh os-image.bin
	@echo "====================================="
	@echo "Run: make run"
	@echo ""

run: os-image.bin
	qemu-system-i386 -display gtk -m 64M -drive format=raw,file=$<

debug: os-image.bin
	qemu-system-i386 -display gtk -m 64M -drive format=raw,file=$< -s -S

clean:
	@echo "Cleaning..."
	@rm -f *.o *.bin os-image.bin
	@rm -f drivers/*.o fs/*.o shell/*.o lib/*.o
	@echo "Done!"

.PHONY: all run debug clean


keyboard.c
#include "keyboard.h"
#include "vga.h"

static const char scancode_to_ascii[128] = {
    0,  27, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b',
    '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n',
    0,    'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`',
    0,    '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 0,
    '*',  0,  ' '
};

static inline uint8_t inb(uint16_t port) {
    uint8_t value;
    __asm__ volatile ("inb %1, %0" : "=a"(value) : "Nd"(port));
    return value;
}

void keyboard_init(void) {
    while (inb(0x64) & 1) inb(0x60);
}

int keyboard_has_input(void) {
    return (inb(0x64) & 1);
}

char keyboard_getchar(void) {
    while (1) {
        if (!keyboard_has_input()) continue;
        
        uint8_t scancode = inb(0x60);
        if (scancode & 0x80) continue;
        
        if (scancode < 128) {
            char c = scancode_to_ascii[scancode];
            if (c) return c;
        }
    }
}

void keyboard_readline(char* buffer, int max_len) {
    int pos = 0;
    
    while (1) {
        char c = keyboard_getchar();
        
        if (c == '\n') {
            buffer[pos] = '\0';
            vga_putch('\n');
            return;
        }
        
        if (c == '\b') {
            if (pos > 0) {
                pos--;
                vga_putch('\b');
            }
            continue;
        }
        
        if (pos < max_len - 1 && c >= 32 && c <= 126) {
            buffer[pos++] = c;
            vga_putch(c);
        }
    }
}


keyboard.h
#ifndef KEYBOARD_H
#define KEYBOARD_H

#include <stdint.h>

void keyboard_init(void);
char keyboard_getchar(void);
int keyboard_has_input(void);
void keyboard_readline(char* buffer, int max_len);

#endif

vga.c
#include "vga.h"

#define VGA_WIDTH 80
#define VGA_HEIGHT 25
#define VGA_MEMORY ((uint16_t*)0xB8000)

static uint8_t vga_color = (VGA_COLOR_LIGHT_GREY | (VGA_COLOR_BLACK << 4));
static int cursor_row = 0;
static int cursor_col = 0;

static inline void outb(uint16_t port, uint8_t value) {
    __asm__ volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
}

static uint16_t vga_entry(char c, uint8_t color) {
    return (uint16_t)c | ((uint16_t)color << 8);
}

static void update_cursor(void) {
    uint16_t pos = cursor_row * VGA_WIDTH + cursor_col;
    outb(0x3D4, 14);
    outb(0x3D5, (pos >> 8) & 0xFF);
    outb(0x3D4, 15);
    outb(0x3D5, pos & 0xFF);
}

void vga_set_color(uint8_t fg, uint8_t bg) {
    vga_color = fg | (bg << 4);
}

void vga_clear(void) {
    for (int y = 0; y < VGA_HEIGHT; y++) {
        for (int x = 0; x < VGA_WIDTH; x++) {
            VGA_MEMORY[y * VGA_WIDTH + x] = vga_entry(' ', vga_color);
        }
    }
    cursor_row = 0;
    cursor_col = 0;
    update_cursor();
}

void vga_init(void) {
    vga_color = VGA_COLOR_LIGHT_GREY | (VGA_COLOR_BLACK << 4);
    vga_clear();
}

void vga_putch(char c) {
    if (c == '\b') {
        // BACKSPACE - FIX FINAL
        if (cursor_col > 0) {
            cursor_col--;
            // Tulis spasi untuk menghapus karakter
            VGA_MEMORY[cursor_row * VGA_WIDTH + cursor_col] = vga_entry(' ', vga_color);
            update_cursor();
        }
        return;
    }
    
    if (c == '\n') {
        cursor_col = 0;
        cursor_row++;
    } else if (c >= 32 && c <= 126) {
        VGA_MEMORY[cursor_row * VGA_WIDTH + cursor_col] = vga_entry(c, vga_color);
        cursor_col++;
        
        if (cursor_col >= VGA_WIDTH) {
            cursor_col = 0;
            cursor_row++;
        }
    }
    
    if (cursor_row >= VGA_HEIGHT) {
        // Scroll up
        for (int y = 0; y < VGA_HEIGHT - 1; y++) {
            for (int x = 0; x < VGA_WIDTH; x++) {
                VGA_MEMORY[y * VGA_WIDTH + x] = VGA_MEMORY[(y + 1) * VGA_WIDTH + x];
            }
        }
        // Clear last line
        for (int x = 0; x < VGA_WIDTH; x++) {
            VGA_MEMORY[(VGA_HEIGHT - 1) * VGA_WIDTH + x] = vga_entry(' ', vga_color);
        }
        cursor_row = VGA_HEIGHT - 1;
    }
    
    update_cursor();
}

void vga_puts(const char* str) {
    while (*str) {
        vga_putch(*str++);
    }
}

void vga_print_int(int num) {
    if (num == 0) {
        vga_putch('0');
        return;
    }
    
    if (num < 0) {
        vga_putch('-');
        num = -num;
    }
    
    char buffer[12];
    int i = 0;
    
    while (num > 0) {
        buffer[i++] = '0' + (num % 10);
        num /= 10;
    }
    
    while (i > 0) {
        vga_putch(buffer[--i]);
    }
}

void vga_print_hex(uint32_t num) {
    vga_puts("0x");
    const char hex[] = "0123456789ABCDEF";
    for (int i = 28; i >= 0; i -= 4) {
        vga_putch(hex[(num >> i) & 0xF]);
    }
}

int vga_get_cursor_col(void) {
    return cursor_col;
}

int vga_get_cursor_row(void) {
    return cursor_row;
}

void vga_set_cursor(int row, int col) {
    cursor_row = row;
    cursor_col = col;
    update_cursor();
}

void vga_clear_eol(void) {
    for (int x = cursor_col; x < VGA_WIDTH; x++) {
        VGA_MEMORY[cursor_row * VGA_WIDTH + x] = vga_entry(' ', vga_color);
    }
}

void vga_draw_box(int row, int col, int width, int height, uint8_t fg, uint8_t bg) {
    uint8_t old_color = vga_color;
    vga_color = fg | (bg << 4);
    
    vga_set_cursor(row, col);
    vga_putch('+');
    for (int i = 0; i < width - 2; i++) vga_putch('-');
    vga_putch('+');
    
    for (int y = 1; y < height - 1; y++) {
        vga_set_cursor(row + y, col);
        vga_putch('|');
        vga_set_cursor(row + y, col + width - 1);
        vga_putch('|');
    }
    
    vga_set_cursor(row + height - 1, col);
    vga_putch('+');
    for (int i = 0; i < width - 2; i++) vga_putch('-');
    vga_putch('+');
    
    vga_color = old_color;
}


vga.h
#ifndef VGA_H
#define VGA_H

#include <stdint.h>

// Basic functions
void vga_init(void);
void vga_clear(void);
void vga_putch(char c);
void vga_puts(const char* str);
void vga_set_color(uint8_t fg, uint8_t bg);

// Cursor functions
int vga_get_cursor_col(void);
int vga_get_cursor_row(void);
void vga_set_cursor(int row, int col);

// Enhanced functions
void vga_print_int(int num);
void vga_print_hex(uint32_t num);
void vga_clear_eol(void);
void vga_draw_box(int row, int col, int width, int height, uint8_t fg, uint8_t bg);

// VGA Color definitions
#define VGA_COLOR_BLACK         0
#define VGA_COLOR_BLUE          1
#define VGA_COLOR_GREEN         2
#define VGA_COLOR_CYAN          3
#define VGA_COLOR_RED           4
#define VGA_COLOR_MAGENTA       5
#define VGA_COLOR_BROWN         6
#define VGA_COLOR_LIGHT_GREY    7
#define VGA_COLOR_DARK_GREY     8
#define VGA_COLOR_LIGHT_BLUE    9
#define VGA_COLOR_LIGHT_GREEN   10
#define VGA_COLOR_LIGHT_CYAN    11
#define VGA_COLOR_LIGHT_RED     12
#define VGA_COLOR_LIGHT_MAGENTA 13
#define VGA_COLOR_YELLOW        14
#define VGA_COLOR_WHITE         15

#endif


fs.c
#include "fs.h"
#include "../lib/string.h"

static inode_t inodes[MAX_FILES];
static inode_t* root = 0;
static inode_t* cwd = 0;

void fs_init(void) {
    for (int i = 0; i < MAX_FILES; i++) {
        inodes[i].used = 0;
    }
    
    root = &inodes[0];
    root->used = 1;
    root->type = INODE_DIR;
    strcpy(root->name, "/");
    root->size = 0;
    root->parent = 0;
    root->child_count = 0;
    
    cwd = root;
}

inode_t* fs_get_root(void) {
    return root;
}

inode_t* fs_get_cwd(void) {
    return cwd;
}

void fs_set_cwd(inode_t* dir) {
    if (dir && dir->type == INODE_DIR) {
        cwd = dir;
    }
}

static inode_t* alloc_inode(void) {
    for (int i = 0; i < MAX_FILES; i++) {
        if (!inodes[i].used) {
            inodes[i].used = 1;
            inodes[i].child_count = 0;
            inodes[i].size = 0;
            memset(inodes[i].data, 0, MAX_FILE_SIZE);
            return &inodes[i];
        }
    }
    return 0;
}

inode_t* fs_create_file(inode_t* parent, const char* name) {
    if (!parent || parent->type != INODE_DIR) return 0;
    if (parent->child_count >= MAX_FILES) return 0;
    if (fs_find_child(parent, name)) return 0;
    
    inode_t* file = alloc_inode();
    if (!file) return 0;
    
    strncpy(file->name, name, MAX_FILENAME - 1);
    file->type = INODE_FILE;
    file->parent = parent;
    
    parent->children[parent->child_count++] = file;
    return file;
}

inode_t* fs_create_dir(inode_t* parent, const char* name) {
    if (!parent || parent->type != INODE_DIR) return 0;
    if (parent->child_count >= MAX_FILES) return 0;
    if (fs_find_child(parent, name)) return 0;
    
    inode_t* dir = alloc_inode();
    if (!dir) return 0;
    
    strncpy(dir->name, name, MAX_FILENAME - 1);
    dir->type = INODE_DIR;
    dir->parent = parent;
    
    parent->children[parent->child_count++] = dir;
    return dir;
}

inode_t* fs_find_child(inode_t* parent, const char* name) {
    if (!parent || parent->type != INODE_DIR) return 0;
    
    for (int i = 0; i < parent->child_count; i++) {
        if (strcmp(parent->children[i]->name, name) == 0) {
            return parent->children[i];
        }
    }
    return 0;
}

int fs_write_file(inode_t* file, const char* data, uint32_t size) {
    if (!file || file->type != INODE_FILE) return -1;
    if (size > MAX_FILE_SIZE) size = MAX_FILE_SIZE;
    
    memcpy(file->data, data, size);
    file->size = size;
    return size;
}

int fs_read_file(inode_t* file, char* buffer, uint32_t size) {
    if (!file || file->type != INODE_FILE) return -1;
    
    uint32_t read_size = (size < file->size) ? size : file->size;
    memcpy(buffer, file->data, read_size);
    return read_size;
}

int fs_delete(inode_t* parent, const char* name) {
    if (!parent || parent->type != INODE_DIR) return -1;
    
    for (int i = 0; i < parent->child_count; i++) {
        if (strcmp(parent->children[i]->name, name) == 0) {
            inode_t* node = parent->children[i];
            
            if (node->type == INODE_DIR && node->child_count > 0) {
                return -1;
            }
            
            node->used = 0;
            
            for (int j = i; j < parent->child_count - 1; j++) {
                parent->children[j] = parent->children[j + 1];
            }
            parent->child_count--;
            return 0;
        }
    }
    return -1;
}

void fs_get_path(inode_t* node, char* buffer) {
    if (!node) {
        buffer[0] = '\0';
        return;
    }
    
    if (node == root) {
        strcpy(buffer, "/");
        return;
    }
    
    char temp[MAX_PATH];
    temp[0] = '\0';
    
    inode_t* current = node;
    while (current && current != root) {
        char new_temp[MAX_PATH];
        strcpy(new_temp, "/");
        strcat(new_temp, current->name);
        strcat(new_temp, temp);
        strcpy(temp, new_temp);
        current = current->parent;
    }
    
    strcpy(buffer, temp);
}


fs.h
#ifndef FS_H
#define FS_H

#include <stdint.h>

#define MAX_FILES 64
#define MAX_FILENAME 32
#define MAX_FILE_SIZE 4096
#define MAX_PATH 256

typedef enum {
    INODE_FILE,
    INODE_DIR
} inode_type_t;

typedef struct inode {
    char name[MAX_FILENAME];
    inode_type_t type;
    uint32_t size;
    char data[MAX_FILE_SIZE];
    struct inode* parent;
    struct inode* children[MAX_FILES];
    int child_count;
    uint8_t used;
} inode_t;

void fs_init(void);
inode_t* fs_get_root(void);
inode_t* fs_get_cwd(void);
void fs_set_cwd(inode_t* dir);

inode_t* fs_create_file(inode_t* parent, const char* name);
inode_t* fs_create_dir(inode_t* parent, const char* name);
inode_t* fs_find_child(inode_t* parent, const char* name);
int fs_write_file(inode_t* file, const char* data, uint32_t size);
int fs_read_file(inode_t* file, char* buffer, uint32_t size);
int fs_delete(inode_t* parent, const char* name);
void fs_get_path(inode_t* node, char* buffer);

#endif


stdint.h
#ifndef STDINT_H
#define STDINT_H

typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef signed short int16_t;
typedef unsigned short uint16_t;
typedef signed int int32_t;
typedef unsigned int uint32_t;
typedef signed long long int64_t;
typedef unsigned long long uint64_t;

typedef uint32_t size_t;
typedef int32_t ssize_t;

#define INT8_MIN   (-128)
#define INT8_MAX   (127)
#define UINT8_MAX  (255)
#define INT16_MIN  (-32768)
#define INT16_MAX  (32767)
#define UINT16_MAX (65535)
#define INT32_MIN  (-2147483648)
#define INT32_MAX  (2147483647)
#define UINT32_MAX (4294967295U)

#define NULL ((void*)0)

#endif


string.c
#include "string.h"

int strlen(const char* str) {
    int len = 0;
    while (str[len]) len++;
    return len;
}

int strcmp(const char* s1, const char* s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(unsigned char*)s1 - *(unsigned char*)s2;
}

int strncmp(const char* s1, const char* s2, int n) {
    while (n && *s1 && (*s1 == *s2)) {
        s1++;
        s2++;
        n--;
    }
    if (n == 0) return 0;
    return *(unsigned char*)s1 - *(unsigned char*)s2;
}

char* strcpy(char* dest, const char* src) {
    char* ret = dest;
    while ((*dest++ = *src++));
    return ret;
}

char* strncpy(char* dest, const char* src, int n) {
    char* ret = dest;
    while (n && (*dest++ = *src++)) n--;
    while (n--) *dest++ = '\0';
    return ret;
}

char* strcat(char* dest, const char* src) {
    char* ret = dest;
    while (*dest) dest++;
    while ((*dest++ = *src++));
    return ret;
}

int memcmp(const void* s1, const void* s2, int n) {
    const unsigned char* p1 = s1;
    const unsigned char* p2 = s2;
    while (n--) {
        if (*p1 != *p2) return *p1 - *p2;
        p1++;
        p2++;
    }
    return 0;
}

void* memcpy(void* dest, const void* src, int n) {
    char* d = dest;
    const char* s = src;
    while (n--) *d++ = *s++;
    return dest;
}

void* memset(void* s, int c, int n) {
    unsigned char* p = s;
    while (n--) *p++ = (unsigned char)c;
    return s;
}


string.h
#ifndef STRING_H
#define STRING_H

#include <stdint.h>

int strlen(const char* str);
int strcmp(const char* s1, const char* s2);
int strncmp(const char* s1, const char* s2, int n);
char* strcpy(char* dest, const char* src);
char* strncpy(char* dest, const char* src, int n);
char* strcat(char* dest, const char* src);
int memcmp(const void* s1, const void* s2, int n);
void* memcpy(void* dest, const void* src, int n);
void* memset(void* s, int c, int n);

#endif


shell.c
#include "shell.h"
#include "../drivers/vga.h"
#include "../drivers/keyboard.h"
#include "../fs/fs.h"
#include "../lib/string.h"

#define CMD_BUFFER_SIZE 256

static char cmd_buffer[CMD_BUFFER_SIZE];

static inline uint8_t inb(uint16_t port) {
    uint8_t value;
    __asm__ volatile ("inb %1, %0" : "=a"(value) : "Nd"(port));
    return value;
}

static inline void outb(uint16_t port, uint8_t value) {
    __asm__ volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
}

static void show_welcome(void) {
    vga_set_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK);
    vga_puts("================================\n");
    vga_puts("     Welcome to MiniOS v1.0     \n");
    vga_puts("================================\n\n");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    vga_puts("Type 'help' for available commands\n\n");
}

static void print_prompt(void) {
    char path[MAX_PATH];
    fs_get_path(fs_get_cwd(), path);
    
    vga_set_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK);
    vga_puts("minios");
    vga_set_color(VGA_COLOR_WHITE, VGA_COLOR_BLACK);
    vga_puts(":");
    vga_set_color(VGA_COLOR_LIGHT_BLUE, VGA_COLOR_BLACK);
    vga_puts(path);
    vga_set_color(VGA_COLOR_WHITE, VGA_COLOR_BLACK);
    vga_puts("$ ");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
}

static void print_help(void) {
    vga_set_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK);
    vga_puts("\nMiniOS Shell Commands:\n\n");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    vga_puts("  help          - Show this help\n");
    vga_puts("  clear         - Clear screen\n");
    vga_puts("  ls            - List files\n");
    vga_puts("  pwd           - Print working directory\n");
    vga_puts("  cd <path>     - Change directory\n");
    vga_puts("  mkdir <name>  - Create directory\n");
    vga_puts("  touch <file>  - Create file\n");
    vga_puts("  cat <file>    - Display file (press 'q' to exit)\n");
    vga_puts("  echo <text> > <file> - Write to file\n");
    vga_puts("  write <file>  - Edit file (:wq save, :q exit)\n");
    vga_puts("  rm <name>     - Remove file/dir\n");
    vga_puts("  tree          - Show directory tree\n");
    vga_puts("  info          - System information\n");
    vga_puts("  reboot        - Reboot system\n\n");
}

static void cmd_ls(void) {
    inode_t* dir = fs_get_cwd();
    
    if (dir->child_count == 0) {
        vga_puts("(empty)\n");
        return;
    }
    
    for (int i = 0; i < dir->child_count; i++) {
        inode_t* child = dir->children[i];
        
        if (child->type == INODE_DIR) {
            vga_set_color(VGA_COLOR_LIGHT_BLUE, VGA_COLOR_BLACK);
            vga_puts(child->name);
            vga_puts("/\n");
        } else {
            vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
            vga_puts(child->name);
            vga_set_color(VGA_COLOR_DARK_GREY, VGA_COLOR_BLACK);
            vga_puts(" (");
            vga_print_int(child->size);
            vga_puts(" bytes)\n");
        }
    }
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
}

static void cmd_pwd(void) {
    char path[MAX_PATH];
    fs_get_path(fs_get_cwd(), path);
    vga_puts(path);
    vga_putch('\n');
}

static void cmd_cd(const char* path) {
    if (strcmp(path, "..") == 0) {
        inode_t* parent = fs_get_cwd()->parent;
        if (parent) fs_set_cwd(parent);
        return;
    }
    
    if (strcmp(path, "/") == 0) {
        fs_set_cwd(fs_get_root());
        return;
    }
    
    inode_t* dir = fs_find_child(fs_get_cwd(), path);
    if (!dir) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("cd: no such directory\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    if (dir->type != INODE_DIR) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("cd: not a directory\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    fs_set_cwd(dir);
}

static void cmd_mkdir(const char* name) {
    if (!name || name[0] == '\0') {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("mkdir: missing name\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    inode_t* dir = fs_create_dir(fs_get_cwd(), name);
    if (!dir) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("mkdir: cannot create directory\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    }
}

static void cmd_touch(const char* name) {
    if (!name || name[0] == '\0') {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("touch: missing name\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    inode_t* file = fs_create_file(fs_get_cwd(), name);
    if (!file) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("touch: cannot create file\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    }
}

static void cmd_cat(const char* name) {
    if (!name || name[0] == '\0') {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("cat: missing filename\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    inode_t* file = fs_find_child(fs_get_cwd(), name);
    if (!file) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("cat: file not found\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    if (file->type != INODE_FILE) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("cat: is a directory\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    vga_putch('\n');
    vga_set_color(VGA_COLOR_YELLOW, VGA_COLOR_BLACK);
    for (uint32_t i = 0; i < file->size; i++) {
        vga_putch(file->data[i]);
    }
    if (file->size > 0 && file->data[file->size - 1] != '\n') {
        vga_putch('\n');
    }
    vga_set_color(VGA_COLOR_DARK_GREY, VGA_COLOR_BLACK);
    vga_puts("\n[Press 'q' to exit]\n");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    
    while (1) {
        char c = keyboard_getchar();
        if (c == 'q' || c == 'Q') break;
    }
}

static void cmd_echo(const char* args) {
    char text[256];
    char filename[MAX_FILENAME];
    int i = 0, j = 0;
    
    while (args[i] && args[i] != '>') {
        if (args[i] != ' ' || j > 0) {
            text[j++] = args[i];
        }
        i++;
    }
    while (j > 0 && text[j-1] == ' ') j--;
    text[j] = '\0';
    
    if (args[i] != '>') {
        vga_puts(text);
        vga_putch('\n');
        return;
    }
    
    i++;
    while (args[i] == ' ') i++;
    j = 0;
    while (args[i] && j < MAX_FILENAME - 1) {
        filename[j++] = args[i++];
    }
    filename[j] = '\0';
    
    if (filename[0] == '\0') {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("echo: missing filename\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    inode_t* file = fs_find_child(fs_get_cwd(), filename);
    if (!file) {
        file = fs_create_file(fs_get_cwd(), filename);
    }
    
    if (!file) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("echo: cannot write\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    fs_write_file(file, text, strlen(text));
}

static void cmd_write(const char* name) {
    if (!name || name[0] == '\0') {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("write: missing filename\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    inode_t* file = fs_find_child(fs_get_cwd(), name);
    if (!file) {
        file = fs_create_file(fs_get_cwd(), name);
    }
    
    if (!file || file->type != INODE_FILE) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("write: cannot create file\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    vga_set_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK);
    vga_puts("\n======== Text Editor ========\n");
    vga_puts("File: ");
    vga_set_color(VGA_COLOR_YELLOW, VGA_COLOR_BLACK);
    vga_puts(name);
    vga_putch('\n');
    vga_set_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK);
    vga_puts("Commands:\n");
    vga_puts("  :wq  - Save and exit\n");
    vga_puts("  :q   - Exit without saving\n");
    vga_puts("=============================\n\n");
    vga_set_color(VGA_COLOR_YELLOW, VGA_COLOR_BLACK);
    
    char buffer[MAX_FILE_SIZE];
    int pos = 0;
    
    while (pos < MAX_FILE_SIZE - 1) {
        char c = keyboard_getchar();
        
        if (c == '\n') {
            // Check for command before adding newline
            // Check :wq
            if (pos >= 3 && buffer[pos-3] == ':' && 
                buffer[pos-2] == 'w' && buffer[pos-1] == 'q') {
                pos -= 3;  // Remove :wq
                buffer[pos] = '\0';
                fs_write_file(file, buffer, pos);
                vga_putch('\n');
                vga_set_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK);
                vga_puts("\nFile saved! (");
                vga_print_int(pos);
                vga_puts(" bytes)\n\n");
                vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
                return;
            }
            
            // Check :q
            if (pos >= 2 && buffer[pos-2] == ':' && buffer[pos-1] == 'q') {
                vga_putch('\n');
                vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
                vga_puts("\nCancelled (not saved)\n\n");
                vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
                return;
            }
            
            // Normal newline
            buffer[pos++] = '\n';
            vga_putch('\n');
            continue;
        }
        
        if (c == '\b') {
            // Allow backspace even through newlines
            if (pos > 0) {
                pos--;
                // If we're deleting a newline, we need special handling
                if (buffer[pos] == '\n') {
                    // Move cursor up and to end of previous line
                    int row = vga_get_cursor_row();
                    int col = 0;
                    
                    // Find the column position by counting back to previous newline
                    int temp = pos - 1;
                    while (temp >= 0 && buffer[temp] != '\n') {
                        col++;
                        temp--;
                    }
                    
                    if (row > 0) {
                        vga_set_cursor(row - 1, col);
                        // Clear the current line
                        vga_clear_eol();
                    }
                } else {
                    vga_putch('\b');
                }
            }
            continue;
        }
        
        if (c >= 32 && c <= 126) {
            buffer[pos++] = c;
            vga_putch(c);
        }
    }
    
    vga_putch('\n');
    vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
    vga_puts("\nBuffer full!\n\n");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
}

static void cmd_rm(const char* name) {
    if (!name || name[0] == '\0') {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("rm: missing name\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        return;
    }
    
    if (fs_delete(fs_get_cwd(), name) != 0) {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts("rm: cannot remove\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    }
}

static void tree_recursive(inode_t* node, int depth) {
    for (int i = 0; i < depth; i++) {
        vga_puts("  ");
    }
    
    if (node->type == INODE_DIR) {
        vga_set_color(VGA_COLOR_LIGHT_BLUE, VGA_COLOR_BLACK);
        vga_puts(node->name);
        vga_puts("/\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
        
        for (int i = 0; i < node->child_count; i++) {
            tree_recursive(node->children[i], depth + 1);
        }
    } else {
        vga_puts(node->name);
        vga_putch('\n');
    }
}

static void cmd_tree(void) {
    tree_recursive(fs_get_root(), 0);
}

static void cmd_info(void) {
    vga_set_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK);
    vga_puts("\n=== MiniOS System Information ===\n\n");
    vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    vga_puts("OS Name:      MiniOS\n");
    vga_puts("Version:      1.0\n");
    vga_puts("Architecture: x86 (32-bit)\n");
    vga_puts("Memory:       64 MB\n");
    vga_puts("Filesystem:   In-memory\n\n");
}

static void cmd_reboot(void) {
    vga_puts("Rebooting...\n");
    uint8_t temp;
    __asm__ volatile("cli");
    do {
        temp = inb(0x64);
        if (temp & 1) inb(0x60);
    } while (temp & 2);
    outb(0x64, 0xFE);
    for(;;) __asm__ volatile("hlt");
}

static void parse_and_execute(const char* cmd) {
    if (cmd[0] == '\0') return;
    
    char command[32];
    char args[CMD_BUFFER_SIZE];
    int i = 0, j = 0;
    
    while (cmd[i] == ' ') i++;
    
    while (cmd[i] && cmd[i] != ' ' && j < 31) {
        command[j++] = cmd[i++];
    }
    command[j] = '\0';
    
    while (cmd[i] == ' ') i++;
    j = 0;
    while (cmd[i]) {
        args[j++] = cmd[i++];
    }
    args[j] = '\0';
    
    if (strcmp(command, "help") == 0) {
        print_help();
    } else if (strcmp(command, "clear") == 0) {
        vga_clear();
        show_welcome();
    } else if (strcmp(command, "ls") == 0) {
        cmd_ls();
    } else if (strcmp(command, "pwd") == 0) {
        cmd_pwd();
    } else if (strcmp(command, "cd") == 0) {
        cmd_cd(args);
    } else if (strcmp(command, "mkdir") == 0) {
        cmd_mkdir(args);
    } else if (strcmp(command, "touch") == 0) {
        cmd_touch(args);
    } else if (strcmp(command, "cat") == 0) {
        cmd_cat(args);
    } else if (strcmp(command, "echo") == 0) {
        cmd_echo(args);
    } else if (strcmp(command, "write") == 0) {
        cmd_write(args);
    } else if (strcmp(command, "rm") == 0) {
        cmd_rm(args);
    } else if (strcmp(command, "tree") == 0) {
        cmd_tree();
    } else if (strcmp(command, "info") == 0) {
        cmd_info();
    } else if (strcmp(command, "reboot") == 0) {
        cmd_reboot();
    } else {
        vga_set_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK);
        vga_puts(command);
        vga_puts(": command not found\n");
        vga_set_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK);
    }
}

void shell_init(void) {
    show_welcome();
}

void shell_run(void) {
    while (1) {
        print_prompt();
        keyboard_readline(cmd_buffer, CMD_BUFFER_SIZE);
        parse_and_execute(cmd_buffer);
    }
}


shell.h
#ifndef SHELL_H
#define SHELL_H

void shell_init(void);
void shell_run(void);

#endif
